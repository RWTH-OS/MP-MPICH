USAGE AND IMPLEMENTATION OF MULTI-DEVICE CONFIGURATIONS IN MP-MPICH

1. Usage

To enable the usage of multiple devices with MP-MPICH, you have to call the top-level configure-script with a list of those devices that you want to use. E. g. to be able to use ch_shmem and ch_smi, you may call configure this way: ./configure --with-device=ch_shmem,ch_smi ... . The list of devices is comma-separated and additional options for each device may be supplied after a colon, e. g. ./configure --with-device=ch_shmem:<ch_shmem options>,ch_smi:<ch_smi options>. This should work for meta- and non-meta-configurations. As a result of this, static and dynamic libraries for all configured devices are built.
If you link an MPI program with the mpicc-script without the -mpistatic option, the devices are not linked to the executable. Instead, they are loaded at runtime (precisely: at startup, after it is known what device to use; on how to select a device, see below). If you use -mpistatic, all devices are statically linked to the executable.
If you use the mpirun-script to start an MPI program, you can select the device to use via the -machine command line option, e.g. ./mpirun -machine ch_smi ... would select the ch_smi device for this run. If you don't supply mpirun with the -machine option, the default device is chosen which is always the first one that was given to the configure-script, e.g. ch_shmem in the above example. Please keep in mind that you may have to change other options if you change the selected device, e.g. the -nodes option for ch_smi is useless for the ch_shmem device.
If you want to start the MPI processes directly without using mpirun, you can select the device with the -usedevice option (of course, this is what mpirun does for you). This time you must know the number of the device to select it. The first device that was given to the configure script gets number 0, the second number 1 and so on. To select the ch_smi device in he above example, you have to do this: ./<program name> -usedevice 1 ... . If you start multiple processes by hand (e.g. for the ch_smi device), all of them have to be given the right device number. As with the mpirun-script, you may have to change other options if you change the selected device.
The startup-mechanism should also work for meta- and non-meta-configurations. In case you are using a meta-configuration, you choose your native device in the meta configuration file, from which the call to mpirun with the right -machine option is generated. If you don't want to use multiple devices, you can do everything as before in building the library, linking against it with mpicc and starting your applications. The only difference here is that if you don't link statically, the device is loaded at runtime and not linked dynamically to the executable.
The are two issues regarding the usage of GCC and Linux: First, if use want to use GCC, you have to make sure that your environment variable $CC is set to gcc or supply configure with the --with-cc=gcc option. Having $CC set to cc does not work, even if cc is just a symlink to gcc. We should change configure.in to solve this in the future. Second, dlopen() only works on dynamic executables. If you link your MPI program statically against all libraries (including the system libraries, so that you don't have a dynamic executable any more), dlopen() will not work properly. So even in the static case, you should link against at least one library dynamically (which is of course the default for the system libraries anyway).
Another issue that I've just discovered: If you use ch_smi and have your executable dynamically linked against the MP-MPICH libraries, please also build a shared version of libcsmi and make sure that it is in you LD_LIBRARY_PATH (after having done a call to rsh, e.g. put it in you ~/.bashrc file). The usage of ch_smi does not work with the static version of the SMI library if you link dynamically. Te reason for this is that there are no unresolved symbols that can be resolved with libcsmi.a and therefore it is not linked to your executable if you don't link against the static version of libch_smi.


2. Implememtation

The implementation of multiple-device configurations included numerous changes in the top-level configure.in and various Makefile.in's. Most of this was done to no longer build just one, but all chosen devices. For each device, a static version in the lib directory and a dynamic version in the lib/shared directory is built. The information, which devices to built is gathered in the configure script in several variables, e.g. for the ch_smi device DEVICE_ch_smi is 1 if the ch_smi device was chosen and 0 otherwise and DEVICE_ARGS_ch_smi is a list of options for this device. If part of a source file has to be conditionally compiled dependend on whether ch_smi was selected, you can use the macro CH_SMI_PRESENT, which is defined in this case. The related preprocessor flag -DCH_SMI_PRESENT is added to $CFLAGS by configure. The device number is saved by configure in the mpichconf.h header file (which is generated from mpichconf.h.in). The macro DEVICE_ch_smi_nbr is set to the device number of ch_smi if ch_smi is present in the library. All of this applies to the other supported devices analogously.
The point of connection between a device and the rest of MP-MPICH is the function MPID_CH_<device>_InitMsgPass() (each device used to have a function called MPID_CH_InitMsgPass(), but now the names are different among the devices to avoid namespace clashes). Each device is initialized by a call to this function ( in MPID_Init() [adi2init.c] and MPIR_init_metaconfig() [initutil.c] ). The call is now done by de-referencing a function pointer called MPID_CH_<device>_InitMsgPassPt. It is set to the function by first looking up the function in the running process. If the device is statically linked to the library, the function symbol is found there. If it is not found, dynamic linking is assumed and MP-MPICH tries to open the dynamic device library via dlopen(). If this could be done successfully, the function symbol can now be resolved and the function pointer be set.
The call to the linker had to be changed for the dynamic loading of the device libraries to work. In the static case, we must supply it with the option -u MPID_CH_<device>_InitMsgPass for each device to be used. This adds MPID_CH_<device>_InitMsgPass to the list of unresolved symbols. If this options is omitted, the static library is not linked to the executable because there are no unresolved symbols that could be resolved by linking it and then the linker does not link it. (To be precise: The linker does not link the whole library but unpacks the archive and links those objects that define unresolved symbols. As a result, if we use the -u option with the given symbol, all object files of the device are linked.) In the dynamic case, if we use GCC, the option -rdynamic had to be added in order to get dlopen() and dlsym() to work properly. The additional command line options for the linker are gathered in $CLINKERDYNAMICOPTS and $CLINKERSTATICOPTS in the configure script.
The device code is now only in libch_<device>.a and libch_<device>.so and never in the main MP_MPICH library (libmpich.a / libmetampi.a ). The code of ch_tunnel and ch_gateway is not in the device libraries but in libmetampi.a / libmetampi.so.
