#!/bin/sh
#
# mpirun.ch_usock for starting MPI applications via the ch_usock device
# based on mpirun.ch_smi for the ch_smi device in many respects

#
# some important variables
#
common_options="" # command line options for all started processes
master_options="" # command line options only for the master process
client_options="" # command line options only for the client processes

#
# function definitions
#
nbr() { echo $#;}

# tell the world who I am
if [ $mpirun_verbose -gt 1 ] ; then
    echo "*** This is mpirun.ch_usock running on `hostname`"
fi

# where are we, and where should the programm run?
BASENAME=`basename $progname`
DIRNAME=`dirname $progname`
if [ -z "$workingdir" ] ; then
    EXENAME=./$BASENAME
    WDNAME=$DIRNAME
else
    EXENAME=$progname
    WDNAME=$workingdir
fi

#
# get the names of the hosts to run the processes on
# the names supplied via '-nodes' have precedence over those in the machine file
# we look for the machine file in some defined places if none is given on the command line
# if no host names are given, we run everything on the local host
# if the number of processes was not given, we start exactly 1 process
#
if [ -n "$nodes" ] ; then
# if the user supplied a list of nodes on the command line, use these nodes
    HOSTS=$nodes
else
# try to find a machine file and use the nodes contained therein
    if [ -z "$machineFile" ] ; then
	if [ -f ./machines ] ; then
	    machineFile=$DIRNAME"/machines"
	elif [ -f $HOME/.machines ] ; then
	    machineFile="$HOME/.machines"
	elif [ -f $datadir/machines ] ; then
	    machineFile="$datadir/machines"
	fi
    fi

    if [ -n "$machineFile" ] ; then
	# we have a machine file, get the nodes from it
	if [ ${mpirun_verbose} != 0 ] ; then
	    echo "*** mpirun.ch_usock: using "$machineFile" to specify the hosts"
	fi
	HOSTS=`cat $machineFile | awk -F\  'NF==0 {exit} NF==1 { print $1 } NF==2 { for (i = $2; i > 0; i--) print $1 }  NF==3 { for (i=$2; i>0; i--) print $1" "$3}'` 
	# increment the first process if it is a prcogroup file
	# aditionally allow otional login and flags parameter
	if test -n "$givenPGFile"  ; then
		HOSTS=`cat $machineFile | awk -F\  'NF==0 {exit} \
						    NF==1 { print $1 } \
						    NF==3 { if (FNR==1) $2++;for (i=$2; i>0; i--) print $1":"$3} \
						    NF==4 { if (FNR==1) $2++;for (i=$2; i>0; i--) print $1":"$3":"$4} \
						    NF>=5 { if (FNR==1) $2++;for (i=$2; i>0; i--) print $1":"$3":"$4":"$5"§"$6"§"$7"§"$8"§"$9"§"$10"§"$11"§"$12}'` 
	fi
    else
	HOSTS=`hostname`
	if [ ${mpirun_verbose} != 0 ] ; then
	    echo "*** mpirun.ch_usock: no machines file found, running all processes on $HOSTS"
	fi
    fi
fi

NBR_HOSTS=`nbr ${HOSTS}`

if [ ${np} -eq 0 ] ; then
    # number of processes not given on command line -> we start one process per node
    np=`nbr ${HOSTS}`
    if [ ${mpirun_verbose} != 0 ] ; then
	echo "*** mpirun.ch_usock: number of processes not explicitly stated -> starting ${np} processes (one per node)"
    fi
fi

# if we now have more hosts than number of processes, we eliminate some hosts from our list
# -> the np processes run on the first np hosts
if [ ${np} -lt ${NBR_HOSTS} ] ; then
    NEWHOSTS=""
    i=0
    for h in $HOSTS ; do
	if [ $i -lt ${np} ] ; then
	    NEWHOSTS="${NEWHOSTS} $h"
	    i=`expr $i + 1`;
	fi
    done
    HOSTS=${NEWHOSTS}
fi

# if more processes are requested than nodes are given in the command line, 
# schedule the processes in round-robin manner
if [ ${np} -gt ${NBR_HOSTS} ] ; then
    NEWHOSTS=$HOSTS
    while [ $NBR_HOSTS -lt $np ] ; do
	for h in $HOSTS ; do
	    NEWHOSTS="$NEWHOSTS $h"
	    NBR_HOSTS=`expr $NBR_HOSTS + 1`
	    if [ $NBR_HOSTS = $np ] ; then
		break;
	    fi
	done
    done
    HOSTS=$NEWHOSTS
fi

# the first host gets the master process
for h in ${HOSTS} ; do
    MASTER_HOST=`echo ${h} | cut -d ":" -f 1`
    break;
done
if [ ${mpirun_verbose} != 0 ] ; then
    echo "*** mpirun.ch_usock: master process running on ${MASTER_HOST}"
fi

# if the user supplied no port range, set it to default:
if [ -z "${port_range}" ] ; then
    port_range="49152-65535"
fi

if [ ${mpirun_verbose} -gt 1 ] ; then
    echo "*** mpirun.ch_usock: port range is ${port_range}"
fi

lower_port_bound=`echo $port_range | sed 's/-.*//g'`
upper_port_bound=`echo $port_range | sed 's/[^-]*-//g'`
port_range=$[$upper_port_bound - $lower_port_bound]

if [ $lower_port_bound -ge $upper_port_bound ] ; then
# only one port was supplied, so use it:
   port_nbr=$lower_port_bound
else
# create a randomized port by using the local process id: 
   port_nbr=$[$$ % $port_range]
   port_nbr=$[$lower_port_bound + $port_nbr]
fi

common_options="${common_options} -p ${port_nbr}"

if [ ${mpirun_verbose} != 0 ] ; then
    echo "*** mpirun.ch_usock: listening port is ${port_nbr}"
fi

device_nbr=`cat $includedir/mpichconf.h | grep DEVICE_ch_usock_nbr | awk  '{ print $3 }'`
common_options="${common_options} -usedevice ${device_nbr}"

# the master process (and only the master process) gets the number of processes ...
master_options="${master_options} -n ${np}"

# ... whereas the clients get the name of the host on which the master is running instead
client_options="${client_options} -m ${MASTER_HOST}"


# it's either echo or eval and in the latter case we just omit it
if [ "${Show}" != "echo" ] ; then
    Show=""
fi

# if cmdLineArgs already contain --, we get rid of it first, to not have it twice
# this happens when using the meta device
tmpLineArgs=""
for c in $cmdLineArgs
  do
  if [ "$c" != '"--"' ] ; then
      tmpLineArgs="$tmpLineArgs $c"
  fi
done
cmdLineArgs=$tmpLineArgs

# build the commands to launch the processes
is_master=1
rank_count=1
for h in ${HOSTS} ; do
	THIS_USER=""
	THIS_ARGS=""
    if [ x != x`echo $h | grep ":"` ] ; then
    	THIS_EXENAME=`echo $h | cut -d:  -f 2`
	THIS_USER=`echo $h | cut -d: -f 3`
	THIS_ARGS=`echo $h | cut -d: -f 4`
	if test -n "$THIS_ARGS" ; then common_options=`echo $THIS_ARGS | sed 's/§/ /g'`; fi
	h=`echo $h | cut -d:  -f 1`
    else
    	THIS_EXENAME=${EXENAME}
    fi
    if [ ${is_master} -eq 1 ] ; then
	# the first process is the master process
	master_launch_cmd="$Show $rshcmd $h ( cd ${WDNAME} ; ${THIS_EXENAME} ${common_options} ${master_options} -r 0 -- ${cmdLineArgs} )"
	is_master=0
    else
	# this is a client process
	client_launch_cmd="$Show $rshcmd $h ' ( cd ${WDNAME} ; ${THIS_EXENAME} ${common_options} ${client_options} -r ${rank_count} -- ${cmdLineArgs} ) ' &"
	eval $client_launch_cmd
	rank_count=$[$rank_count+1]
    fi
done

${master_launch_cmd}

